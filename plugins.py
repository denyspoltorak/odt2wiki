# A placeholder for row-wide CSS grid items
class Wide:
    pass

# Customization by the output dialect
class Strategy:
    file_extension = ".md"
    needs_navigation = True
        
    @staticmethod
    def make_ref_for_header(rel_path, header, is_title):
        # https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#section-links
        if is_title:
            # Title od a wiki page is not rendered - we rely on file name instead, therefore the reference leads to the file
            return rel_path
        else:
            output = []
            for c in header.strip():
                if c.isalnum():
                    output.append(c.lower())
                elif c in " -":
                    output.append("-")
            return rel_path + "#" + "".join(output)
    
    @staticmethod
    def make_ref_for_text(rel_path, text, is_title):
        assert not is_title
        return rel_path + "#" + "".join([c.lower() for c in text.split()[0] if c.isalnum()])
    
    @staticmethod
    def resolve_refs_conflict(anchor, links):
        # https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#section-links
        assert len(links) > 1
        output = []
        for l in links[0]:
            output.append((l, anchor))
        for i in range(1, len(links)):
            new_anchor = anchor + "-" + str(i)
            for l in links[i]:
                output.append((l, new_anchor))
        return output
    
    @staticmethod
    def process_internal_link(link):
        return f"<{link}>" if link else "#"
    
    @staticmethod
    def string_to_filename(string):
        return string.rstrip(". ")
    
    @staticmethod
    def index_filename(string):
        return string


# Per-document customization
class Customization:
    subtitle = None
    grid_wide_class = None
    
    # Here you can edit a section after it has been loaded from the parser
    @staticmethod
    def preprocess(section):
        pass
    
    # Does this split_level section need to be split even further into subsections?
    @staticmethod
    def needs_split(section):
        return False
    
    # Does this folder-level section need a local ToC to provide links to its children?
    @staticmethod
    def needs_local_toc(section):
        return False
    
    # Do we use a 1-level or 2-level CSS Grid and which style to show a table of contents instead of a list?
    @staticmethod
    def toc_grid_depth_and_style(section):
        return None
    
    # Hides the section from local (Hugo Book) search and sitemap.xml
    @staticmethod
    def is_hidden(section):
        return False
    
    # Priority for sitemap.xml, from 0 to 1
    @staticmethod
    def get_sitemap_priority(section):
        return 0.5
    
    # Return SEO description (up to 160 chars)
    @staticmethod
    def get_description(section):
        return None
    
    # Return an image for sharing the page on social networks and messengers
    @staticmethod
    def get_preview_image(section):
        return None
    
    # Return an image for showing in a CSS-grid-based table of contents, Wide() for a row-length item or None for text
    @staticmethod
    def get_toc_image(section_name):
        return None
    
    # Return path to an image for the dark theme
    @staticmethod
    def get_dark_image(light_image):
        return None


# Analytics - it skips the root section (the autogenerated Table of Contents)
class Analytics:  
    def make(self, root):
        self._set_root(root)
        for c in root.children:
            c.traverse(self)
        return self._finalize()
    
    def __call__(self, section):
        assert section.header.outline_level
        return self._process_chapter(section) if section.has_file() else self._process_subsection(section)
    
    def _process_chapter(self, section):
        return True
    
    def _process_subsection(self, section):
        return False
    
    def _set_root(self, root):
        pass
    
    def _finalize(self):
        pass